# UI Protocol Spec（Core ⇄ TUI/Desktop）

This document covers the Rust UI (TUI/future Desktop) and the TypeScript side execution runtime (core + tools).
Defines a **bidirectional protocol** to be used between.

Premise:
- `AgentEvent` of `packages/core/src/types/events/*` is a “domain event” generated by **core's runStream**.
- To connect with UI, `AgentEvent` alone is not enough, **envelope (IPC) + UI→core input + core→UI request** is required.

This specification assumes `packages/protocol` is the canonical source.

---

## 0. Purpose / Non-purpose

the purpose:
- Make the UI and execution runtime **loosely coupled** (enabling TUI/GUI replacement)
- Ensure compatibility (version/capabilities) and extensibility (namespacing)
- Support cases that require intervention from the UI, such as “selection/confirmation/input”

Non-purpose:
- Delegate “UI internal operations (key input/focus movement)” to core (UI is owned by UI)
- token-by-token LLM stream (extended with provider/separate event if necessary)

---

## 1. Role (Actor)

- **UI**: Rust TUI (in the future, Desktop UI will also use the same protocol)
- **Runtime**: TS side process (including core + tools). From the UI’s perspective, it’s a “server”

> The current `packages/core` is a library, so it does not speak the protocol as it is.
> To connect from TUI, it is assumed that an **IPC server** is placed on `packages/cli` (or `packages/runtime` in the future).

---

## 2. Transport

### 2.1 Recommended: stdio

- UI spawns Runtime and communicates bidirectionally with `stdin/stdout`
- **stdout is for protocol only**, logs are output to **stderr** (prevents stdout pollution)

### 2.2 Message framing（v0）

v0 adopts **NDJSON (JSON Lines)**:
- 1 row = 1 JSON object
- UTF-8
- Each message ends with `\n`

future:
- If you need a large payload or strict boundaries, move to length-prefix (negotiate with version of `initialize`)

---

## 3. Wire Envelope

This protocol adopts a form compatible with JSON-RPC 2.0 (for ease of implementation and correlation).

```ts
export type RpcId = string;

export type RpcRequest = {
  jsonrpc: "2.0";
  id: RpcId;
  method: string;
  params?: unknown;
};

export type RpcResponse = {
  jsonrpc: "2.0";
  id: RpcId;
  result?: unknown;
  error?: { code: number; message: string; data?: unknown };
};

export type RpcNotification = {
  jsonrpc: "2.0";
  method: string;
  params?: unknown;
};

export type RpcMessage = RpcRequest | RpcResponse | RpcNotification;
```

Design policy:
- Request/response requires **correlation id** (needs to wait with UI confirm etc.)
- notification is fire-and-forget (without `id`)
- `params` **allows future expansion** (does not discard unknown/extra fields)

---

## 4. Versioning / Capabilities

### 4.1 `initialize` (required)

The UI sends `initialize` immediately after connecting.

`initialize` request params (example):
```ts
export type InitializeParams = {
protocol_version: string; // Example: "0"
  client: { name: string; version: string };
  ui_capabilities?: UiCapabilities;
};
```

`initialize` response result (example):
```ts
export type InitializeResult = {
protocol_version: string; // version that server can speak (same if compatible)
  server: { name: string; version: string };
  server_capabilities?: ServerCapabilities;
};
```

### 4.2 Capabilities (Example)

UI side:
- `supports_confirm`, `supports_prompt`, `supports_pick`
- `supports_markdown`, `supports_images`

Runtime side:
- `supports_run_cancel`
- `supports_ui_requests` (Using Runtime→UI request)
- `supports_mcp_list` (You can obtain the MCP runtime status with `mcp.list`)
- `supports_skills_list` (you can get skills catalog with `skills.list`)

---

## 5. Run model (“one run”)

The chat UI is usually ``one user utterance = one agent execution.''
This one time is called `run`.

### 5.1 `run.start` (required)

UI → Runtime request。

params (example):
```ts
export type RunStartParams = {
  input: { type: "text"; text: string };
  session_id?: string; // optional resume target
ui_context?: UiContextSnapshot; // Optional: current active file / selection etc.
  meta?: Record<string, unknown>;
};
```

result (example):
```ts
export type RunStartResult = {
  run_id: string;
};
```

### 5.2 `agent.event` (required)

Runtime → UI notification. Carry `AgentEvent`.

params (example):
```ts
export type AgentEventNotify = {
  run_id: string;
  seq: number;              // 0..N（ordering）
  event: AgentEvent;        // packages/core/src/types/events
meta?: Record<string, unknown>; // Future extensions (structured output, etc.)
};
```

> Since `AgentEvent` itself is a core “display event”, it is fine as long as the UI draws it directly.
> However, for future expansion, wire has `seq` and `meta` on the envelope side.

Additional notes (`text` and `final`):
- `final` is an event that indicates "this turn is completed" and also has a body text.
- `text` is a body event for progress/streaming (may become incremental in the future).
- The UI does not depend on both `text` and `final` coming (there are cases where the body comes only with `final`).

See `docs/specs/run-visibility.md` for UI rendering guidelines based on these events.

### 5.3 `run.cancel` (recommended)

UI → Runtime request。

params (example):
```ts
export type RunCancelParams = { run_id: string; reason?: string };
```

result (example):
```ts
export type RunCancelResult = {
  ok: boolean;
  status?: "running" | "completed" | "error" | "cancelled";
};
```

Runtime should treat run.cancel as best-effort and idempotent.
If the run is active, it must attempt to stop LLM calls and tool execution and
then emit `run.status` with `status: "cancelled"`.
If the run already completed, Runtime may return `ok: false` or `status: "completed"`.
After a cancelled status, no further agent events should be emitted for that run.

### 5.4 `session.list` (recommended)

UI → Runtime request. Get the session list for Resume.

params (example):
```ts
export type SessionListParams = {
  limit?: number; // default: 50
};
```

result (example):
```ts
export type SessionListResult = {
  sessions: Array<{
    session_id: string;
    updated_at: string;
    run_id?: string;
    message_count?: number;
    last_user_message?: string;
  }>;
};
```

### 5.5 `session.history` (recommended)

UI → Runtime request. Play the session history (agent.event).

params (example):
```ts
export type SessionHistoryParams = {
  session_id: string;
  max_runs?: number;   // default: 20
  max_events?: number; // default: 1500
};
```

result (example):
```ts
export type SessionHistoryResult = {
  runs: number;
  events_sent: number;
  truncated?: boolean;
};
```

### 5.4 `run.status` (optional)

Runtime → UI notification。

```ts
export type RunStatusNotify = {
  run_id: string;
  status: "running" | "awaiting_ui" | "completed" | "error" | "cancelled";
  message?: string;
};
```

Notes:
- `status: "cancelled"` is terminal. UI should stop spinners and treat the run as ended.
- A cancelled run may not emit a final AgentEvent. UI must not wait for `final` if a
  terminal `run.status` is observed.

### 5.5 `run.context` (optional)

Runtime → UI notification。

```ts
export type RunContextNotify = {
  run_id: string;
  context_left_percent: number; // 0-100
};
```

### 5.6 `model.list` (optional)

UI → Runtime request。

params (example):
```ts
export type ModelListParams = {
  provider?: string; // default: "openai"
  include_details?: boolean; // default: false
};
```

result (example):
```ts
export type ModelListResult = {
  provider: string;
  models: string[];
  current?: string;
  details?: Record<string, {
    context_window?: number;
    max_input_tokens?: number;
    max_output_tokens?: number;
  }>;
};
```

### 5.7 `model.set` (optional)

UI → Runtime request。

params (example):
```ts
export type ModelSetParams = {
  name: string;
  provider?: string; // default: "openai"
};
```

result (example):
```ts
export type ModelSetResult = {
  provider: string;
  name: string;
};
```

### 5.8 `mcp.list` (recommended, used with `/mcp`)

UI → Runtime request。

params (example):
```ts
export type McpListParams = {
  scope?: "loaded" | "configured"; // default: "loaded"
};
```

result (example):
```ts
export type McpListResult = {
  servers: Array<{
    id: string;
    transport: "http" | "stdio";
    source?: "project" | "global";
    enabled: boolean;
    state: "disabled" | "connecting" | "ready" | "error";
    tools?: number;
    last_error?: string;
    last_connected_at?: string;
  }>;
};
```

Requirements:
- UI calls `mcp.list(scope="loaded")` when `/mcp` is displayed.
- Runtime can process `mcp.list` even during run execution.
- If `supports_mcp_list=false`, the UI will display "MCP status unavailable".

### 5.9 `skills.list` (recommended, used with `/skills`)

UI → Runtime request。

params (example):
```ts
export type SkillsListParams = {
  cwd?: string;
  force_reload?: boolean; // default: false
};
```

result (example):
```ts
export type SkillsListResult = {
  skills: Array<{
    id: string;
    name: string;
    description: string;
    path: string;
    dir: string;
    scope: "repo" | "user";
    mtime_ms: number;
  }>;
  errors: Array<{ path: string; message: string }>;
  truncated: boolean;
};
```

Requirements:
- The UI calls `skills.list` when `/skills` is displayed and reflects it to the local picker (search/scope/filter).
- If `supports_skills_list=false`, the UI will display "Skills list unavailable".

---

## 6. UI → Runtime (Input/Context)

### 6.1 `ui.context.update` (recommended)

The “selected/active file” etc. are held by the UI and shared with the Runtime only when necessary.
Do not send raw key events (do not impose UI convenience).

```ts
export type UiContextUpdateParams = {
// Minimum: “Where are you working now?”
  cwd?: string;
  workspace_root?: string;

  active_file?: { path: string; language_id?: string };

  selection?: {
    path: string;
// 0-based. end is recommended to be exclusive.
    range: {
      start: { line: number; column: number };
      end: { line: number; column: number };
    };
// Optional: If the UI can be generated immediately, include it (if not, core will use the read_file tool)
    selected_text?: string;
  };

// For future expansion
  extensions?: Record<string, unknown>;
};
```

`UiContextSnapshot` is an alias for including the “current UI state” in run.start.
```ts
export type UiContextSnapshot = UiContextUpdateParams;
```

Usage:
- push before agent execution (pass “latest” along with `ui_context` of run.start)
- Push every time the selection changes (but debounce if the frequency is high)

---

## 7. Runtime → UI（confirm/prompt/pick）

“Approving dangerous operations” and “selecting from candidates” require UI support.
This is treated as a **Runtime→UI request** (you can wait for the response).

### 7.1 `ui.confirm.request` (recommended)

Runtime → UI request、UI → Runtime response。

params (example):
```ts
export type UiConfirmRequestParams = {
  run_id?: string;
  title: string;
  message: string;
  confirm_label?: string; // default: "OK"
  cancel_label?: string;  // default: "Cancel"
  danger_level?: "normal" | "danger";
  allow_remember?: boolean; // default: false
  allow_reason?: boolean;   // default: false
};
```

result (example):
```ts
export type UiConfirmResult = {
  ok: boolean;
  remember?: boolean; // remember allow/deny choice if supported
  reason?: string;    // optional free-form reason for deny
};
```

### 7.2 `ui.prompt.request` (optional)

```ts
export type UiPromptRequestParams = {
  run_id?: string;
  title: string;
  message: string;
  default_value?: string;
  multiline?: boolean;
  secret?: boolean;
};
export type UiPromptResult = { value: string | null }; // cancel => null
```

### 7.3 `ui.pick.request` (optional)

```ts
export type UiPickRequestParams = {
  run_id?: string;
  title: string;
  items: Array<{ id: string; label: string; detail?: string }>;
  multi?: boolean;
};
export type UiPickResult = { ids: string[] }; // cancel => []
```

---

## 8. Additional categories that are likely to be needed (in the future)

When developing TUI/desktop as a “coding agent UI” you will likely need:

- **Artifacts**: Handle diff/image/long log with `artifact_id` reference (large capacity countermeasure)
- **Workspace API**: `workspace.list/read/search` for UI to display file tree / preview
- **History API**: Get and export conversation history/tool history
- **Task/ToDo**: `todos.update` etc. that works with planning tools
- **Clipboard**: Handle copy/paste explicitly (useful in TUI)

These are not required for v0, but keep the method namespace:
- `artifact.*`
- `workspace.*`
- `history.*`
- `todos.*`

---

## 9. Error codes (draft)

- `-32601` method not found（JSON-RPC）
- `-32602` invalid params
- `-32001` runtime busy (simultaneous run limit, etc.)
- `-32002` run not found
- `-32003` user cancelled

---

## 10. Examples（NDJSON）

initialize:
```json
{"jsonrpc":"2.0","id":"1","method":"initialize","params":{"protocol_version":"0","client":{"name":"codelia-tui","version":"0.0.0"}}}
```
```json
{"jsonrpc":"2.0","id":"1","result":{"protocol_version":"0","server":{"name":"codelia-runtime","version":"0.0.0"}}}
```

run.start:
```json
{"jsonrpc":"2.0","id":"2","method":"run.start","params":{"input":{"type":"text","text":"List TypeScript files"}}}
```
```json
{"jsonrpc":"2.0","id":"2","result":{"run_id":"run_123"}}
```

agent.event（notification）:
```json
{"jsonrpc":"2.0","method":"agent.event","params":{"run_id":"run_123","seq":0,"event":{"type":"reasoning","content":"...","timestamp":1730000000000}}}
```

ui.confirm.request（runtime→UI request）:
```json
{"jsonrpc":"2.0","id":"9","method":"ui.confirm.request","params":{"run_id":"run_123","title":"Run command?","message":"rg -n \"AgentEvent\" -S packages"}}
```
```json
{"jsonrpc":"2.0","id":"9","result":{"ok":true}}
```
