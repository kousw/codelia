# UI Protocol Spec（Core ⇄ TUI/Desktop）

This document covers the Rust UI (TUI/future Desktop) and the TypeScript side execution runtime (core + tools).
Defines a **bidirectional protocol** to be used between.

Premise:
- `AgentEvent` of `packages/core/src/types/events/*` is a “domain event” generated by **core's runStream**.
- To connect with UI, `AgentEvent` alone is not enough, **envelope (IPC) + UI→core input + core→UI request** is required.

This specification assumes `packages/protocol` is the canonical source.

---

## 0. Purpose / Non-purpose

the purpose:
- Make the UI and execution runtime **loosely coupled** (enabling TUI/GUI replacement)
- Ensure compatibility (version/capabilities) and extensibility (namespacing)
- Support cases that require intervention from the UI, such as “selection/confirmation/input”

Non-purpose:
- Delegate “UI internal operations (key input/focus movement)” to core (UI is owned by UI)
- token-by-token LLM stream (extended with provider/separate event if necessary)

---

## 1. Role (Actor)

- **UI**: Rust TUI (in the future, Desktop UI will also use the same protocol)
- **Runtime**: TS side process (including core + tools). From the UI’s perspective, it’s a “server”

> The current `packages/core` is a library, so it does not speak the protocol by itself.
> Runtime protocol server is implemented in `packages/runtime`, and TUI/Desktop connect to it over stdio JSON-RPC.

---

## 2. Transport

### 2.1 Recommended: stdio

- UI spawns Runtime and communicates bidirectionally with `stdin/stdout`
- **stdout is for protocol only**, logs are output to **stderr** (prevents stdout pollution)

### 2.2 Message framing（v0）

v0 adopts **NDJSON (JSON Lines)**:
- 1 row = 1 JSON object
- UTF-8
- Each message ends with `\n`

future:
- If you need a large payload or strict boundaries, move to length-prefix (negotiate with version of `initialize`)

---

## 3. Wire Envelope

This protocol adopts a form compatible with JSON-RPC 2.0 (for ease of implementation and correlation).

```ts
export type RpcId = string;

export type RpcRequest = {
  jsonrpc: "2.0";
  id: RpcId;
  method: string;
  params?: unknown;
};

export type RpcResponse = {
  jsonrpc: "2.0";
  id: RpcId;
  result?: unknown;
  error?: { code: number; message: string; data?: unknown };
};

export type RpcNotification = {
  jsonrpc: "2.0";
  method: string;
  params?: unknown;
};

export type RpcMessage = RpcRequest | RpcResponse | RpcNotification;
```

Design policy:
- Request/response requires **correlation id** (needs to wait with UI confirm etc.)
- notification is fire-and-forget (without `id`)
- `params` **allows future expansion** (does not discard unknown/extra fields)

---

## 4. Versioning / Capabilities

### 4.1 `initialize` (required)

The UI sends `initialize` immediately after connecting.

`initialize` request params (example):
```ts
export type InitializeParams = {
protocol_version: string; // Example: "0"
  client: { name: string; version: string };
  ui_capabilities?: UiCapabilities;
};
```

`initialize` response result (example):
```ts
export type InitializeResult = {
protocol_version: string; // version that server can speak (same if compatible)
  server: { name: string; version: string };
  server_capabilities?: ServerCapabilities;
  tui?: {
    theme?: string; // resolved effective TUI theme
  };
};
```

### 4.2 Capabilities (Example)

UI side:
- `supports_confirm`, `supports_prompt`, `supports_pick`
- `supports_markdown`, `supports_images`
- Planned extension for remote-runtime mode: `supports_clipboard_read`
  (see `docs/specs/tui-remote-runtime-ssh.md`)

Runtime side:
- `supports_run_cancel`
- `supports_ui_requests` (Using Runtime→UI request)
- `supports_mcp_list` (You can obtain the MCP runtime status with `mcp.list`)
- `supports_skills_list` (you can get skills catalog with `skills.list`)
- `supports_context_inspect` (you can inspect resolved agents/skills/runtime context with `context.inspect`)
- `supports_tool_call` (you can execute built-in runtime tools directly with `tool.call`)
- `supports_shell_exec` (you can execute UI-origin shell command with `shell.exec`)
  (see `docs/specs/tui-bang-shell-mode.md`)

---

## 5. Run model (“one run”)

The chat UI is usually ``one user utterance = one agent execution.''
This one time is called `run`.

### 5.1 `run.start` (required)

UI → Runtime request。

params (example):
```ts
export type RunStartParams = {
  input: { type: "text"; text: string };
  session_id?: string; // optional resume target
  force_compaction?: boolean; // optional one-shot compaction run
  ui_context?: UiContextSnapshot; // Optional: current active file / selection etc.
  meta?: Record<string, unknown>;
};
```

result (example):
```ts
export type RunStartResult = {
  run_id: string;
};
```

### 5.2 `agent.event` (required)

Runtime → UI notification. Carry `AgentEvent`.

params (example):
```ts
export type AgentEventNotify = {
  run_id: string;
  seq: number;              // 0..N（ordering）
  event: AgentEvent;        // packages/core/src/types/events
meta?: Record<string, unknown>; // Future extensions (structured output, etc.)
};
```

> Since `AgentEvent` itself is a core “display event”, it is fine as long as the UI draws it directly.
> However, for future expansion, wire has `seq` and `meta` on the envelope side.

Additional notes (`text` and `final`):
- `final` is an event that indicates "this turn is completed" and also has a body text.
- `text` is a body event for progress/streaming (may become incremental in the future).
- The UI does not depend on both `text` and `final` coming (there are cases where the body comes only with `final`).

See `docs/specs/run-visibility.md` for UI rendering guidelines based on these events.

### 5.3 `run.cancel` (recommended)

UI → Runtime request。

params (example):
```ts
export type RunCancelParams = { run_id: string; reason?: string };
```

result (example):
```ts
export type RunCancelResult = {
  ok: boolean;
  status?: "running" | "completed" | "error" | "cancelled";
};
```

Runtime should treat run.cancel as best-effort and idempotent.
If the run is active, it must attempt to stop LLM calls and tool execution and
then emit `run.status` with `status: "cancelled"`.
If the run already completed, Runtime may return `ok: false` or `status: "completed"`.
After a cancelled status, no further agent events should be emitted for that run.

### 5.4 `session.list` (recommended)

UI → Runtime request. Get the session list for Resume.

params (example):
```ts
export type SessionListParams = {
  limit?: number; // default: 50
};
```

result (example):
```ts
export type SessionListResult = {
  sessions: Array<{
    session_id: string;
    updated_at: string;
    run_id?: string;
    message_count?: number;
    last_user_message?: string;
  }>;
};
```

### 5.5 `session.history` (recommended)

UI → Runtime request. Play the session history (agent.event).

params (example):
```ts
export type SessionHistoryParams = {
  session_id: string;
  max_runs?: number;   // default: 20
  max_events?: number; // default: 1500
};
```

result (example):
```ts
export type SessionHistoryResult = {
  runs: number;
  events_sent: number;
  truncated?: boolean;
};
```

### 5.6 `run.status` (optional)

Runtime → UI notification。

```ts
export type RunStatusNotify = {
  run_id: string;
  status: "running" | "awaiting_ui" | "completed" | "error" | "cancelled";
  message?: string;
};
```

Notes:
- `status: "cancelled"` is terminal. UI should stop spinners and treat the run as ended.
- A cancelled run may not emit a final AgentEvent. UI must not wait for `final` if a
  terminal `run.status` is observed.

### 5.7 `run.context` (optional)

Runtime → UI notification。

```ts
export type RunContextNotify = {
  run_id: string;
  context_left_percent: number; // 0-100
};
```

### 5.7.1 `run.diagnostics` (optional)

Runtime → UI notification.

Use for opt-in diagnostics detail (per-call usage/cache/latency and final run summary).
Recommended gate: diagnostics flag/environment (`--diagnostics` or `CODELIA_DIAGNOSTICS=1`).

```ts
export type RunDiagnosticsNotify =
  | {
      run_id: string;
      kind: "llm_call";
      call: {
        run_id: string;
        seq: number;
        provider?: string;
        model: string;
        request_ts: string;
        response_ts: string;
        latency_ms: number;
        stop_reason?: string | null;
        usage?: {
          input_tokens: number;
          output_tokens: number;
          total_tokens: number;
          input_cached_tokens?: number | null;
          input_cache_creation_tokens?: number | null;
          input_image_tokens?: number | null;
        } | null;
        cache: {
          hit_state: "hit" | "miss" | "unknown";
          cache_read_tokens: number;
          cache_creation_tokens: number;
          cache_read_ratio?: number | null;
        };
        cost_usd?: number | null;
        provider_meta_summary?: string | null;
      };
    }
  | {
      run_id: string;
      kind: "run_summary";
      summary: {
        total_calls: number;
        total_tokens: number;
        total_input_tokens: number;
        total_output_tokens: number;
        total_cached_input_tokens: number;
        total_cache_creation_tokens: number;
        total_cost_usd?: number | null;
        by_model: Record<string, {
          calls: number;
          input_tokens: number;
          output_tokens: number;
          cached_input_tokens: number;
          cache_creation_tokens: number;
          total_tokens: number;
          cost_usd?: number | null;
        }>;
      };
    };
```

Notes:
- Diagnostics must not add/modify `messages` history sent to the LLM.
- Diagnostics payloads are notifications for UI visibility, not session record types.

### 5.8 `model.list` (optional)

UI → Runtime request。

Implementation status (as of 2026-02-12):
- Implemented: `include_details` with token limit fields (`context_window` / `max_input_tokens` / `max_output_tokens`).
- Planned: release-date-aware ordering and normalized cost fields for onboarding/model-picker UX.

params (example):
```ts
export type ModelListParams = {
  provider?: string; // default: "openai"
  include_details?: boolean; // default: false
};
```

result (example):
```ts
export type ModelListResult = {
  provider: string;
  models: string[]; // ordered for UI display (newest first when release date exists)
  current?: string;
  details?: Record<string, {
    release_date?: string; // YYYY-MM-DD (if known)
    context_window?: number;
    max_input_tokens?: number;
    max_output_tokens?: number;
    cost_per_1m_input_tokens_usd?: number;
    cost_per_1m_output_tokens_usd?: number;
  }>;
};
```

Requirements:
- Runtime should return models in newest-first order using `details[model].release_date` when available.
- If release date is missing, runtime should place unknown-date models after dated models and keep stable fallback order.
- Cost fields are normalized as USD per 1M tokens for display-friendly comparison.
- UI may use `Tab` to switch model panel columns between token limits and cost.
- If cost is unavailable for a model, UI should render `-` for cost columns.

### 5.9 `model.set` (optional)

UI → Runtime request。

params (example):
```ts
export type ModelSetParams = {
  name: string;
  provider?: string; // default: "openai"
};
```

result (example):
```ts
export type ModelSetResult = {
  provider: string;
  name: string;
};
```

### 5.10 `tool.call` (optional)

UI -> Runtime request. Directly invoke a runtime tool by name and JSON arguments.

params (example):
```ts
export type ToolCallParams = {
  name: string;
  arguments?: Record<string, unknown>;
};
```

result (example):
```ts
export type ToolCallResult = {
  ok: boolean;
  result: unknown;
};
```

Notes:
- Intended for deterministic UI-driven operations (for example `/lane` interactive actions).
- Runtime should return an RPC error for unknown tool names or malformed params.

### 5.11 `mcp.list` (recommended, used with `/mcp`)

UI → Runtime request。

params (example):
```ts
export type McpListParams = {
  scope?: "loaded" | "configured"; // default: "loaded"
};
```

result (example):
```ts
export type McpListResult = {
  servers: Array<{
    id: string;
    transport: "http" | "stdio";
    source?: "project" | "global";
    enabled: boolean;
    state: "disabled" | "connecting" | "auth_required" | "ready" | "error";
    tools?: number;
    last_error?: string;
    last_connected_at?: string;
  }>;
};
```

Requirements:
- UI calls `mcp.list(scope="loaded")` when `/mcp` is displayed.
- Runtime can process `mcp.list` even during run execution.
- If `supports_mcp_list=false`, the UI will display "MCP status unavailable".

### 5.12 `skills.list` (recommended, used with `/skills`)

UI → Runtime request。

params (example):
```ts
export type SkillsListParams = {
  cwd?: string;
  force_reload?: boolean; // default: false
};
```

result (example):
```ts
export type SkillsListResult = {
  skills: Array<{
    id: string;
    name: string;
    description: string;
    path: string;
    dir: string;
    scope: "repo" | "user";
    mtime_ms: number;
  }>;
  errors: Array<{ path: string; message: string }>;
  truncated: boolean;
};
```

Requirements:
- The UI calls `skills.list` when `/skills` is displayed and reflects it to the local picker (search/scope/filter).
- If `supports_skills_list=false`, the UI will display "Skills list unavailable".

### 5.13 `auth.logout` (optional)

UI → Runtime request.

params (example):
```ts
export type AuthLogoutParams = {
  clear_session?: boolean; // default: true
};
```

result (example):
```ts
export type AuthLogoutResult = {
  ok: boolean;
  auth_cleared: boolean;
  session_cleared: boolean;
  cancelled?: boolean;
};
```

### 5.14 `context.inspect` (optional)

UI → Runtime request.

params (example):
```ts
export type ContextInspectParams = {
  include_agents?: boolean;
  include_skills?: boolean;
};
```

result (example):
```ts
export type ContextInspectResult = {
  runtime_working_dir?: string;
  runtime_sandbox_root?: string;
  ui_context?: {
    cwd?: string;
    workspace_root?: string;
    active_file_path?: string;
  };
  agents?: unknown;
  skills?: unknown;
};
```

### 5.15 `shell.exec` (planned, used by `!` bang shell mode)

UI → Runtime request.

This is a dedicated user-initiated command execution route for TUI bang mode
(`!<command>`). It is intentionally separate from agent tool-call flow.

Detailed contract and injection format are defined in:

- `docs/specs/tui-bang-shell-mode.md`

---

## 6. UI → Runtime (Input/Context)

### 6.1 `ui.context.update` (recommended)

The “selected/active file” etc. are held by the UI and shared with the Runtime only when necessary.
Do not send raw key events (do not impose UI convenience).

```ts
export type UiContextUpdateParams = {
// Minimum: “Where are you working now?”
  cwd?: string;
  workspace_root?: string;

  active_file?: { path: string; language_id?: string };

  selection?: {
    path: string;
// 0-based. end is recommended to be exclusive.
    range: {
      start: { line: number; column: number };
      end: { line: number; column: number };
    };
// Optional: If the UI can be generated immediately, include it (if not, core will use the read_file tool)
    selected_text?: string;
  };

// For future expansion
  extensions?: Record<string, unknown>;
};
```

`UiContextSnapshot` is an alias for including the “current UI state” in run.start.
```ts
export type UiContextSnapshot = UiContextUpdateParams;
```

Usage:
- push before agent execution (pass “latest” along with `ui_context` of run.start)
- Push every time the selection changes (but debounce if the frequency is high)

---

## 7. Runtime → UI（confirm/prompt/pick）

“Approving dangerous operations” and “selecting from candidates” require UI support.
This is treated as a **Runtime→UI request** (you can wait for the response).

### 7.1 `ui.confirm.request` (recommended)

Runtime → UI request、UI → Runtime response。

params (example):
```ts
export type UiConfirmRequestParams = {
  run_id?: string;
  title: string;
  message: string;
  confirm_label?: string; // default: "OK"
  cancel_label?: string;  // default: "Cancel"
  danger_level?: "normal" | "danger";
  allow_remember?: boolean; // default: false
  allow_reason?: boolean;   // default: false
};
```

result (example):
```ts
export type UiConfirmResult = {
  ok: boolean;
  remember?: boolean; // remember allow/deny choice if supported
  reason?: string;    // optional free-form reason for deny
};
```

### 7.2 `ui.prompt.request` (optional)

```ts
export type UiPromptRequestParams = {
  run_id?: string;
  title: string;
  message: string;
  default_value?: string;
  multiline?: boolean;
  secret?: boolean;
};
export type UiPromptResult = { value: string | null }; // cancel => null
```

### 7.3 `ui.pick.request` (optional)

```ts
export type UiPickRequestParams = {
  run_id?: string;
  title: string;
  items: Array<{ id: string; label: string; detail?: string }>;
  multi?: boolean;
};
export type UiPickResult = { ids: string[] }; // cancel => []
```

---

## 8. Additional categories that are likely to be needed (in the future)

When developing TUI/desktop as a “coding agent UI” you will likely need:

- **Artifacts**: Handle diff/image/long log with `artifact_id` reference (large capacity countermeasure)
- **Workspace API**: `workspace.list/read/search` for UI to display file tree / preview
- **History API**: Get and export conversation history/tool history
- **Task/ToDo**: `todos.update` etc. that works with planning tools
- **Clipboard**: Handle copy/paste explicitly (useful in TUI)
  - Planned concrete request for remote-runtime mode:
    `ui.clipboard.read` (see `docs/specs/tui-remote-runtime-ssh.md`)
- **Shell execution**: user-initiated direct execution path
  - Planned concrete request: `shell.exec`
    (see `docs/specs/tui-bang-shell-mode.md`)

These are not required for v0, but keep the method namespace:
- `artifact.*`
- `workspace.*`
- `history.*`
- `todos.*`
- `shell.*`

---

## 9. Error codes (draft)

- `-32601` method not found (JSON-RPC)
- `-32602` invalid params
- `-32000` runtime internal error
- `-32001` runtime busy (simultaneous run limit, etc.)
- `-32002` run not found
- `-32003` user cancelled
- `-32004` session not found
- `-32005` session load/reload failed
- `-32006` session list failed

---

## 10. Examples（NDJSON）

initialize:
```json
{"jsonrpc":"2.0","id":"1","method":"initialize","params":{"protocol_version":"0","client":{"name":"codelia-tui","version":"0.0.0"}}}
```
```json
{"jsonrpc":"2.0","id":"1","result":{"protocol_version":"0","server":{"name":"codelia-runtime","version":"0.0.0"}}}
```

run.start:
```json
{"jsonrpc":"2.0","id":"2","method":"run.start","params":{"input":{"type":"text","text":"List TypeScript files"}}}
```
```json
{"jsonrpc":"2.0","id":"2","result":{"run_id":"run_123"}}
```

agent.event（notification）:
```json
{"jsonrpc":"2.0","method":"agent.event","params":{"run_id":"run_123","seq":0,"event":{"type":"reasoning","content":"...","timestamp":1730000000000}}}
```

ui.confirm.request（runtime→UI request）:
```json
{"jsonrpc":"2.0","id":"9","method":"ui.confirm.request","params":{"run_id":"run_123","title":"Run command?","message":"rg -n \"AgentEvent\" -S packages"}}
```
```json
{"jsonrpc":"2.0","id":"9","result":{"ok":true}}
```


### 5.13 `shell.exec` (optional)

Executes a UI-origin shell command without starting an agent run.

Request params:

- `command: string` (required)
- `timeout_seconds?: number` (default 120, max 300)
- `cwd?: string` (optional, sandbox-root bounded)

Result fields:

- `command_preview: string`
- `exit_code: number | null`
- `signal?: string | null`
- `stdout: string`
- `stderr: string`
- `truncated: { stdout: boolean; stderr: boolean; combined: boolean }`
- `duration_ms: number`
- `stdout_cache_id?: string`
- `stderr_cache_id?: string`

`stdout/stderr` may contain excerpt text when truncated; cache IDs can be used with `tool_output_cache`.
